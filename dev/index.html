<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · EHTModels.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://EHTJulia.github.io/EHTModels.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>EHTModels.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EHTJulia/EHTModels.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="EHTModels"><a class="docs-heading-anchor" href="#EHTModels">EHTModels</a><a id="EHTModels-1"></a><a class="docs-heading-anchor-permalink" href="#EHTModels" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/EHTJulia/EHTModels.jl">EHTModels</a>.</p><ul><li><a href="#EHTModels.AbstractModel"><code>EHTModels.AbstractModel</code></a></li><li><a href="#EHTModels.AbstractModifier"><code>EHTModels.AbstractModifier</code></a></li><li><a href="#EHTModels.AddModel"><code>EHTModels.AddModel</code></a></li><li><a href="#EHTModels.Butterworth"><code>EHTModels.Butterworth</code></a></li><li><a href="#EHTModels.CompositeModel"><code>EHTModels.CompositeModel</code></a></li><li><a href="#EHTModels.ConvolvedModel"><code>EHTModels.ConvolvedModel</code></a></li><li><a href="#EHTModels.DensityAnalytic"><code>EHTModels.DensityAnalytic</code></a></li><li><a href="#EHTModels.Disk"><code>EHTModels.Disk</code></a></li><li><a href="#EHTModels.Gaussian"><code>EHTModels.Gaussian</code></a></li><li><a href="#EHTModels.GeometricModel"><code>EHTModels.GeometricModel</code></a></li><li><a href="#EHTModels.IsAnalytic"><code>EHTModels.IsAnalytic</code></a></li><li><a href="#EHTModels.IsPrimitive"><code>EHTModels.IsPrimitive</code></a></li><li><a href="#EHTModels.NotAnalytic"><code>EHTModels.NotAnalytic</code></a></li><li><a href="#EHTModels.NotPrimitive"><code>EHTModels.NotPrimitive</code></a></li><li><a href="#EHTModels.PrimitiveTrait"><code>EHTModels.PrimitiveTrait</code></a></li><li><a href="#EHTModels.Rectangle"><code>EHTModels.Rectangle</code></a></li><li><a href="#EHTModels.RenormalizedModel"><code>EHTModels.RenormalizedModel</code></a></li><li><a href="#EHTModels.RotatedModel"><code>EHTModels.RotatedModel</code></a></li><li><a href="#EHTModels.ShiftedModel"><code>EHTModels.ShiftedModel</code></a></li><li><a href="#EHTModels.StretchedModel"><code>EHTModels.StretchedModel</code></a></li><li><a href="#Base.:+-Tuple{AbstractModel, AbstractModel}"><code>Base.:+</code></a></li><li><a href="#EHTModels.DiskFilter"><code>EHTModels.DiskFilter</code></a></li><li><a href="#EHTModels.GaussianFilter"><code>EHTModels.GaussianFilter</code></a></li><li><a href="#EHTModels.RectangleFilter"><code>EHTModels.RectangleFilter</code></a></li><li><a href="#EHTModels.added-Tuple{AbstractModel, AbstractModel}"><code>EHTModels.added</code></a></li><li><a href="#EHTModels.basemodel-Tuple{EHTModels.AbstractModifier}"><code>EHTModels.basemodel</code></a></li><li><a href="#EHTModels.components-Tuple{AbstractModel}"><code>EHTModels.components</code></a></li><li><a href="#EHTModels.convolved-Tuple{AbstractModel, AbstractModel}"><code>EHTModels.convolved</code></a></li><li><a href="#EHTModels.create_filter"><code>EHTModels.create_filter</code></a></li><li><a href="#EHTModels.flux"><code>EHTModels.flux</code></a></li><li><a href="#EHTModels.imanalytic-Tuple{Type{&lt;:AbstractModel}}"><code>EHTModels.imanalytic</code></a></li><li><a href="#EHTModels.intensity_point"><code>EHTModels.intensity_point</code></a></li><li><a href="#EHTModels.intensitymap"><code>EHTModels.intensitymap</code></a></li><li><a href="#EHTModels.intensitymap!"><code>EHTModels.intensitymap!</code></a></li><li><a href="#EHTModels.isprimitive"><code>EHTModels.isprimitive</code></a></li><li><a href="#EHTModels.posangle-Tuple{EHTModels.RotatedModel}"><code>EHTModels.posangle</code></a></li><li><a href="#EHTModels.radialextent"><code>EHTModels.radialextent</code></a></li><li><a href="#EHTModels.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:AbstractModel"><code>EHTModels.renormed</code></a></li><li><a href="#EHTModels.rotated-Tuple{Any, Any}"><code>EHTModels.rotated</code></a></li><li><a href="#EHTModels.scale_image"><code>EHTModels.scale_image</code></a></li><li><a href="#EHTModels.scale_uv"><code>EHTModels.scale_uv</code></a></li><li><a href="#EHTModels.shifted-Tuple{Any, Any, Any}"><code>EHTModels.shifted</code></a></li><li><a href="#EHTModels.smoothed-Tuple{Any, Number}"><code>EHTModels.smoothed</code></a></li><li><a href="#EHTModels.stretched-Tuple{Any, Any, Any}"><code>EHTModels.stretched</code></a></li><li><a href="#EHTModels.transform_image"><code>EHTModels.transform_image</code></a></li><li><a href="#EHTModels.transform_uv"><code>EHTModels.transform_uv</code></a></li><li><a href="#EHTModels.visanalytic-Tuple{Type{&lt;:AbstractModel}}"><code>EHTModels.visanalytic</code></a></li><li><a href="#EHTModels.visibility_point"><code>EHTModels.visibility_point</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="EHTModels.AbstractModel" href="#EHTModels.AbstractModel"><code>EHTModels.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractModel</code></pre><p>The abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface: <strong>Mandatory Methods</strong></p><ul><li><a href="#EHTModels.isprimitive"><code>isprimitive</code></a>: defines whether a model is standalone or is defined in terms of other models.  is the model is primitive then this should return <code>IsPrimitive()</code> otherwise it returns  <code>NotPrimitive()</code></li><li><a href="#EHTModels.visanalytic-Tuple{Type{&lt;:AbstractModel}}"><code>visanalytic</code></a>: defines whether the model visibilities can be computed analytically. If yes  then this should return <code>IsAnalytic()</code> and the user <em>must</em> to define <code>visibility_point</code>.  If not analytic then <code>visanalytic</code> should return <code>NotAnalytic()</code>.</li><li><a href="#EHTModels.imanalytic-Tuple{Type{&lt;:AbstractModel}}"><code>imanalytic</code></a>: defines whether the model intensities can be computed pointwise. If yes</li></ul><p>then this should return <code>IsAnalytic()</code> and the user <em>must</em> to define <code>intensity_point</code>. If not analytic then <code>imanalytic</code> should return <code>NotAnalytic()</code>.</p><ul><li><a href="#EHTModels.radialextent"><code>radialextent</code></a>: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.</li><li><a href="#EHTModels.flux"><code>flux</code></a>: Returns the total flux of the model.</li></ul><p><strong>Optional Methods:</strong></p><ul><li><a href="#EHTModels.intensity_point"><code>intensity_point</code></a>: Defines how to compute model intensities pointwise. Note this is must be defined if <code>imanalytic(::Type{YourModel})==IsAnalytic()</code>.</li><li><a href="#EHTModels.visibility_point"><code>visibility_point</code></a>: Defines how to compute model visibilties pointwise. Note this is   must be defined if <code>visanalytic(::Type{YourModel})==IsAnalytic()</code>.</li><li><a href="@ref"><code>_visibilities</code></a>: Vectorized version of <code>visibility_point</code> if you can gain additional speed</li><li><a href="#EHTModels.intensitymap"><code>intensitymap</code></a>: Computes the whole image of the model</li><li><a href="#EHTModels.intensitymap!"><code>intensitymap!</code></a>: Inplace version of <code>intensitymap</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L10-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.AbstractModifier" href="#EHTModels.AbstractModifier"><code>EHTModels.AbstractModifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractModifier{M&lt;:AbstractModel} &lt;: AbstractModel</code></pre><p>Abstract type for image modifiers. These are some model wrappers that can transform any model using simple Fourier transform properties. By default these modified models will have the same analytic properties as the base unmodified model, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; visanalytic(stretched(Disk(), 2.0, 2.0)) == visanalytic(Disk())
true</code></pre><p>Additionally these are classic examples of non-primitive images i.e.,</p><pre><code class="language-julia-repl hljs">julia&gt; isprimitive(Comrade.AbstractModifier) == Comrade.NotAnalytic()</code></pre><p>As a result of this the implementation of a model is slightly different</p><ul><li><a href="#EHTModels.transform_uv"><code>transform_uv</code></a></li><li><a href="#EHTModels.transform_image"><code>transform_image</code></a></li><li><a href="#EHTModels.scale_uv"><code>scale_uv</code></a></li><li><a href="#EHTModels.scale_image"><code>scale_image</code></a></li><li><a href="#EHTModels.radialextent"><code>radialextent</code></a></li></ul><p>This methods assume the modifiers are of the form I(x,y) -&gt; fᵢ(x,y)I(gᵢ(x,y)) V(u,v) -&gt; fᵥ(u,v)V(gᵥ(u,v)) where <code>g</code> are the transform<em>image/uv functions and <code>f</code> are the scale</em>image/uv function. See those docstrings for guidance on implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L4-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.AddModel" href="#EHTModels.AddModel"><code>EHTModels.AddModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AddModel{T1, T2} &lt;: EHTModels.CompositeModel{T1, T2}</code></pre><p>Pointwise addition of two models in the image and visibility domain. An end user should instead call <a href="#EHTModels.added-Tuple{AbstractModel, AbstractModel}"><code>added</code></a> or <code>Base.+</code> when constructing a model</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Disk() + Gaussian()
julia&gt; m2 = added(Disk(), Gaussian()) + Ring()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/combinators.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.Butterworth" href="#EHTModels.Butterworth"><code>EHTModels.Butterworth</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Butterworth{T, N}() where {T}</code></pre><p>Butterwoth filter in the visibility domain, i.e. the fourier-domain profile</p><p class="math-container">\[    V_N(r) = \left[ 1 + \left( \frac{1}{r}\right)^{2N}  \right]^{-1/2}\]</p><p>i.e. a unit filtering length and unit flux filter. By default if T isn&#39;t given, <code>Butterworth</code> defaults to <code>T=Float64</code>. If futher N isn&#39;t given,  <code>Butterworth</code> defaults to <code>N=2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/nongeometric/butterworth.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.CompositeModel" href="#EHTModels.CompositeModel"><code>EHTModels.CompositeModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type CompositeModel{M1, M2} &lt;: AbstractModel</code></pre><p>Abstract type that denotes a composite model. Where we have combined two models together.</p><p><strong>Implementation</strong></p><p>Any implementation of a composite type must define the following methods:</p><ul><li>visibility_point</li><li>uv_combinator</li><li>imanalytic</li><li>visanalytic</li><li>ComradeBase.intensity_point if model intensity is <code>IsAnalytic</code></li><li>intensitymap! if model intensity is <code>NotAnalytic</code></li><li>intensitymap if model intensity is <code>NotAnalytic</code></li><li>flux</li><li>radialextent</li><li>visibilities (optional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/combinators.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.ConvolvedModel" href="#EHTModels.ConvolvedModel"><code>EHTModels.ConvolvedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ConvolvedModel{M1, M2} &lt;: EHTModels.CompositeModel{M1, M2}</code></pre><p>Pointwise addition of two models in the image and visibility domain. An end user should instead call <a href="#EHTModels.convolved-Tuple{AbstractModel, AbstractModel}"><code>convolved</code></a>. Also see <a href="#EHTModels.smoothed-Tuple{Any, Number}"><code>smoothed(m, σ)</code></a> for a simplified function that convolves a model <code>m</code> with a Gaussian with standard deviation <code>σ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/combinators.jl#L174-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.DensityAnalytic" href="#EHTModels.DensityAnalytic"><code>EHTModels.DensityAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityAnalytic</code></pre><p>Internal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.Disk" href="#EHTModels.Disk"><code>EHTModels.Disk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">$(TYPEDEF)</code></pre><p>Uniform disk geometrical model, i.e. the intensity profile</p><p class="math-container">\[    I(x,y) = \begin{cases} \pi^{-1} &amp; x^2+y^2 &lt; 1 \\ 0 &amp; x^2+y^2 \geq 0 \end{cases}\]</p><p>i.e. a unit radius and unit flux disk. By default if T isn&#39;t given, <code>Disk</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/geometric/disk.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.Gaussian" href="#EHTModels.Gaussian"><code>EHTModels.Gaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Gaussian{T} &lt;: GeometricModel</code></pre><p>Gaussian with unit standard deviation and flux. By default if T isn&#39;t given, <code>Gaussian</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/geometric/gaussian.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.GeometricModel" href="#EHTModels.GeometricModel"><code>EHTModels.GeometricModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeometricModel &lt;: AbstractModel</code></pre><p>A type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain. As a result a user only needs to implement the following methods</p><ul><li><code>visibility_point</code></li><li><code>intensity_point</code></li><li><code>radialextent</code></li></ul><p>Note that if the geometric model isn&#39;t <strong>analytic</strong> then the usual methods listed in <a href="@ref"><code>Comrade.AbstractModel</code></a> for non-analytic models need to be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/geometric/geometric.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.IsAnalytic" href="#EHTModels.IsAnalytic"><code>EHTModels.IsAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsAnalytic &lt;: EHTModels.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.IsPrimitive" href="#EHTModels.IsPrimitive"><code>EHTModels.IsPrimitive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct IsPrimitive</code></pre><p>Trait for primitive model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L53-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.NotAnalytic" href="#EHTModels.NotAnalytic"><code>EHTModels.NotAnalytic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotAnalytic &lt;: EHTModels.DensityAnalytic</code></pre><p>Defines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L97-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.NotPrimitive" href="#EHTModels.NotPrimitive"><code>EHTModels.NotPrimitive</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotPrimitive</code></pre><p>Trait for not-primitive model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L58-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.PrimitiveTrait" href="#EHTModels.PrimitiveTrait"><code>EHTModels.PrimitiveTrait</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type PrimitiveTrait</code></pre><p>This trait specifies whether the model is a <em>primitive</em></p><p><strong>Notes</strong></p><p>This will likely turn into a trait in the future so people can inject their models into Comrade more easily.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.Rectangle" href="#EHTModels.Rectangle"><code>EHTModels.Rectangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">$(TYPEDEF)</code></pre><p>Uniform rectangle geometrical model, i.e. the intensity profile</p><p class="math-container">\[    I(x,y) = \begin{cases} 1 &amp; |x| &lt; 0.5 and |y| &lt; 0.5 \\ 0 &amp; (otherwise) \end{cases}\]</p><p>i.e. a unit length and unit flux rectangle. By default if T isn&#39;t given, <code>Rectangle</code> defaults to <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/geometric/rectangle.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.RenormalizedModel" href="#EHTModels.RenormalizedModel"><code>EHTModels.RenormalizedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RenormalizedModel{M&lt;:AbstractModel, T} &lt;: EHTModels.AbstractModifier{M&lt;:AbstractModel}</code></pre><p>Renormalizes the flux of the model to the new value <code>scale*flux(model)</code>. We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this. An end user should not call this directly but instead the <a href="#EHTModels.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:AbstractModel"><code>renormed</code></a> function or Base.:* instead.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; renormed(Gaussian(), 2.0) == 2.0*Gaussian()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L188-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.RotatedModel" href="#EHTModels.RotatedModel"><code>EHTModels.RotatedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RotatedModel{M&lt;:AbstractModel, T} &lt;: EHTModels.AbstractModifier{M&lt;:AbstractModel}</code></pre><p>Type for the rotated model. This is more fine grained constrol of rotated model. An end user should not call this directly but instead the <a href="#EHTModels.rotated-Tuple{Any, Any}"><code>rotated</code></a> function instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L276-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.ShiftedModel" href="#EHTModels.ShiftedModel"><code>EHTModels.ShiftedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ShiftedModel{M&lt;:AbstractModel, T} &lt;: EHTModels.AbstractModifier{M&lt;:AbstractModel}</code></pre><p>Shifts the model by <code>Δx</code> units in the x-direction and <code>Δy</code> units in the y-direction. An end user should not call this directly but instead the <a href="#EHTModels.shifted-Tuple{Any, Any, Any}"><code>shifted</code></a> function instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L151-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.StretchedModel" href="#EHTModels.StretchedModel"><code>EHTModels.StretchedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StretchedModel{M&lt;:AbstractModel, T} &lt;: EHTModels.AbstractModifier{M&lt;:AbstractModel}</code></pre><p>Stretched the model in the x and y directions, i.e. the new intensity is     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux. An end user should not call this directly but instead the <a href="#EHTModels.stretched-Tuple{Any, Any, Any}"><code>stretched</code></a> function instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L243-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{AbstractModel, AbstractModel}" href="#Base.:+-Tuple{AbstractModel, AbstractModel}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:+(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Combine two models to create a composite <a href="@ref Comrade.AddModel"><code>AddModel</code></a>. This adds two models pointwise, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Gaussian()
julia&gt; m2 = Disk()
julia&gt; visibility(m1+m2, 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/combinators.jl#L75-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.DiskFilter" href="#EHTModels.DiskFilter"><code>EHTModels.DiskFilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DiskFilter(θmaj, [θmin, ϕ]; [θunit, ϕunit])</code></pre><p>Create an elliptical Disk filter with the total flux density of unity centered at the origin.</p><p>Args:</p><ul><li><code>θmaj::Real</code>:   The major-axis size of the disk.</li><li><code>θmin::Real</code>:   The minor-axis size of the disk. If <code>θmin &lt; 0</code>, then   <code>θmin = θmax</code> (i.e. circular disk). Default to -1.</li><li><code>ϕ::Real</code>:   The position angle of the elliptical disk. Default to 0.</li><li><code>θunit, ϕunit::Unitful</code>:   The unit for <code>θmaj</code> &amp; <code>θmin</code> and <code>ϕ</code>, respectively.    Default: <code>θunit=rad</code> and <code>ϕ=deg</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/geometric/disk.jl#L27-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.GaussianFilter" href="#EHTModels.GaussianFilter"><code>EHTModels.GaussianFilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">GaussianFilter(θmaj, [θmin, ϕ]; [θunit, ϕunit])</code></pre><p>Create an elliptical Gaussian filter with the total flux density of unity centered at the origin.</p><p>Args:</p><ul><li><code>θmaj::Real</code>:   The major-axis FWHM size of the Gaussian.</li><li><code>θmin::Real</code>:   The minor-axis FWHM size of the Gaussian. If <code>θmin &lt; 0</code>, then   <code>θmin = θmax</code> (i.e. circular Gaussian). Default to -1.</li><li><code>ϕ::Real</code>:   The position angle of the Gausian. Default to 0.</li><li><code>θunit, ϕunit::Unitful</code>:   The unit for <code>θmaj</code> &amp; <code>θmin</code> and <code>ϕ</code>, respectively.    Default: <code>θunit=rad</code> and <code>ϕ=deg</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/geometric/gaussian.jl#L21-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.RectangleFilter" href="#EHTModels.RectangleFilter"><code>EHTModels.RectangleFilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">RectangleFilter(θmaj, [θmin, ϕ]; [θunit, ϕunit])</code></pre><p>Create an rectangle filter with the total flux density of unity.</p><p>Args:</p><ul><li><code>θmaj::Real</code>:   The major-axis size of the rectangle.</li><li><code>θmin::Real</code>:   The minor-axis size of the rectangle. If <code>θmin &lt; 0</code>, then   <code>θmin = θmax</code> (i.e. square). Default to -1.</li><li><code>ϕ::Real</code>:   The position angle of the rectangle. Default to 0.</li><li><code>θunit, ϕunit::Unitful</code>:   The unit for <code>θmaj</code> &amp; <code>θmin</code> and <code>ϕ</code>, respectively.    Default: <code>θunit=rad</code> and <code>ϕ=deg</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/geometric/rectangle.jl#L26-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.added-Tuple{AbstractModel, AbstractModel}" href="#EHTModels.added-Tuple{AbstractModel, AbstractModel}"><code>EHTModels.added</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">added(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Combine two models to create a composite <a href="@ref Comrade.AddModel"><code>AddModel</code></a>. This adds two models pointwise, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Gaussian()
julia&gt; m2 = Disk()
julia&gt; visibility(added(m1,m2), 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/combinators.jl#L89-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.basemodel-Tuple{EHTModels.AbstractModifier}" href="#EHTModels.basemodel-Tuple{EHTModels.AbstractModifier}"><code>EHTModels.basemodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basemodel(model::AbstractModel)</code></pre><p>Returns the base model from a modified <code>model</code>. If there is no basemodel this just return the <code>model</code> itself.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L35-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.components-Tuple{AbstractModel}" href="#EHTModels.components-Tuple{AbstractModel}"><code>EHTModels.components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">components(m::AbstractModel)</code></pre><p>Returns the model components for a composite model. This will return a Tuple with all the models you have constructed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = Gaussian() + Disk()
julia&gt; components(m)
(Gaussian{Float64}(), Disk{Float64}())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/combinators.jl#L103-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.convolved-Tuple{AbstractModel, AbstractModel}" href="#EHTModels.convolved-Tuple{AbstractModel, AbstractModel}"><code>EHTModels.convolved</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convolved(m1::AbstractModel, m2::AbstractModel)</code></pre><p>Convolve two models to create a composite <a href="@ref Comrade.ConvolvedModel"><code>ConvolvedModel</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Ring()
julia&gt; m2 = Disk()
julia&gt; convolved(m1, m2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/combinators.jl#L186-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.create_filter" href="#EHTModels.create_filter"><code>EHTModels.create_filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_filter(AbstractModel, θmaj, [θmin, ϕ]; [θunit, ϕunit]) =&gt; AbstractModel</code></pre><p>Create a filter model by streaching and rotating the given input basemodel.</p><p>Args:</p><ul><li><code>θmaj::Real</code>:   The major-axis size of the rectangle.</li><li><code>θmin::Real</code>:   The minor-axis size of the rectangle. If <code>θmin &lt; 0</code>, then   <code>θmin = θmax</code> (i.e. square). Default to -1.</li><li><code>ϕ::Real</code>:   The position angle of the rectangle. Default to 0.</li><li><code>θunit, ϕunit::Unitful</code>:   The unit for <code>θmaj</code> &amp; <code>θmin</code> and <code>ϕ</code>, respectively.    Default: <code>θunit=rad</code> and <code>ϕ=deg</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/filter.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.flux" href="#EHTModels.flux"><code>EHTModels.flux</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flux(model::AbstractModel)</code></pre><p>Returns the total flux of the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L173-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.imanalytic-Tuple{Type{&lt;:AbstractModel}}" href="#EHTModels.imanalytic-Tuple{Type{&lt;:AbstractModel}}"><code>EHTModels.imanalytic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imanalytic(::Type{&lt;:AbstractModel})</code></pre><p>Determines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point. If <code>IsAnalytic()</code> then it will try to call <code>intensity_point</code> to calculate the intensity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.intensity_point" href="#EHTModels.intensity_point"><code>EHTModels.intensity_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensity_point(model::AbstractModel, x, y, args...)</code></pre><p>Function that computes the pointwise intensity if the model has the trait in the image domain <code>IsAnalytic()</code>. Otherwise it will use construct the image in visibility space and invert it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.intensitymap" href="#EHTModels.intensitymap"><code>EHTModels.intensitymap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap(model::AbstractModel, args...)</code></pre><p>Computes the intensity map of model. For the inplace version see <a href="#EHTModels.intensitymap!"><code>intensitymap!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L159-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.intensitymap!" href="#EHTModels.intensitymap!"><code>EHTModels.intensitymap!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intensitymap!(buffer::AbstractMatrix, model::AbstractModel, args...)</code></pre><p>Computes the intensity map of <code>model</code> by modifying the <code>buffer</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L152-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.isprimitive" href="#EHTModels.isprimitive"><code>EHTModels.isprimitive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isprimitive(::Type)</code></pre><p>Dispatch function that specifies whether a type is a primitive Comrade model. This function is used for dispatch purposes when composing models.</p><p><strong>Notes</strong></p><p>If a user is specifying their own model primitive model outside of Comrade they need to specify if it is primitive</p><pre><code class="language-julia hljs">struct MyPrimitiveModel end
ComradeBase.isprimitive(::Type{MyModel}) = ComradeBase.IsPrimitive()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.posangle-Tuple{EHTModels.RotatedModel}" href="#EHTModels.posangle-Tuple{EHTModels.RotatedModel}"><code>EHTModels.posangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">posangle(model)
</code></pre><p>Returns the rotation angle of the rotated <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L301-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.radialextent" href="#EHTModels.radialextent"><code>EHTModels.radialextent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">radialextent(model::AbstractModel)</code></pre><p>Provides an estimate of the radial size/extent of the <code>model</code>. This is used internally to estimate image size when plotting and using <code>modelimage</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:AbstractModel" href="#EHTModels.renormed-Union{Tuple{M}, Tuple{M, Any}} where M&lt;:AbstractModel"><code>EHTModels.renormed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">renormed(model, f)
</code></pre><p>Renormalizes the model <code>m</code> to have total flux <code>f*flux(m)</code>. This can also be done directly by calling <code>Base.:*</code> i.e.,</p><pre><code class="language-julia-repl hljs">julia&gt; renormed(m, f) == f*M
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L209-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.rotated-Tuple{Any, Any}" href="#EHTModels.rotated-Tuple{Any, Any}"><code>EHTModels.rotated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotated(model, ξ)
</code></pre><p>Rotates the model by an amount <code>ξ</code> in radians in the clockwise direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L295-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.scale_image" href="#EHTModels.scale_image"><code>EHTModels.scale_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_image(model::AbstractModifier, x, y)</code></pre><p>Returns a number of how to to scale the image intensity at <code>x</code> <code>y</code> for an modified <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L58-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.scale_uv" href="#EHTModels.scale_uv"><code>EHTModels.scale_uv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_image(model::AbstractModifier, u, v)</code></pre><p>Returns a number on how to scale the image visibility at <code>u</code> <code>v</code> for an modified <code>model</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L71-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.shifted-Tuple{Any, Any, Any}" href="#EHTModels.shifted-Tuple{Any, Any, Any}"><code>EHTModels.shifted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shifted(model, Δx, Δy)
</code></pre><p>Shifts the model <code>m</code> in the image domain by an amount <code>Δx,Δy</code> in the x and y directions respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.smoothed-Tuple{Any, Number}" href="#EHTModels.smoothed-Tuple{Any, Number}"><code>EHTModels.smoothed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smoothed(m::AbstractModel, σ::Number)</code></pre><p>Smooths a model <code>m</code> with a Gaussian kernel with standard deviation <code>σ</code>.</p><p><strong>Notes</strong></p><p>This uses <a href="#EHTModels.convolved-Tuple{AbstractModel, AbstractModel}"><code>convolved</code></a> to created the model, i.e.</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = Disk()
julia&gt; m2 = Gaussian()
julia&gt; convolved(m1, m2) == smoothed(m1, 1.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/combinators.jl#L197-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.stretched-Tuple{Any, Any, Any}" href="#EHTModels.stretched-Tuple{Any, Any, Any}"><code>EHTModels.stretched</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stretched(model, α, β)
</code></pre><p>Stretches the model <code>m</code> according to the formula     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L258-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.transform_image" href="#EHTModels.transform_image"><code>EHTModels.transform_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_image(model::AbstractModifier, x, y)</code></pre><p>Returns a transformed <code>x</code> and <code>y</code> according to the <code>model</code> modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.transform_uv" href="#EHTModels.transform_uv"><code>EHTModels.transform_uv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_uv(model::AbstractModifier, u, v)</code></pre><p>Returns a transformed <code>u</code> and <code>v</code> according to the <code>model</code> modifier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/modifiers.jl#L77-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.visanalytic-Tuple{Type{&lt;:AbstractModel}}" href="#EHTModels.visanalytic-Tuple{Type{&lt;:AbstractModel}}"><code>EHTModels.visanalytic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">visanalytic(::Type{&lt;:AbstractModel})</code></pre><p>Determines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point. If <code>IsAnalytic()</code> then it will try to call <code>visibility_point</code> to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L106-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EHTModels.visibility_point" href="#EHTModels.visibility_point"><code>EHTModels.visibility_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visibility_point(model::AbstractModel, u, v, args...)</code></pre><p>Function that computes the pointwise visibility. This must be implemented in the model interface if <code>visanalytic(::Type{MyModel}) == IsAnalytic()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EHTJulia/EHTModels.jl/blob/d791660c3e3229278f10e62a5866418a3fad1e70/src/abstractmodel/abstractmodel.jl#L136-L140">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 17 February 2023 12:12">Friday 17 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
