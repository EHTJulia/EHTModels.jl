var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = EHTModels","category":"page"},{"location":"#EHTModels","page":"Home","title":"EHTModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for EHTModels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EHTModels]","category":"page"},{"location":"#EHTModels.AbstractModel","page":"Home","title":"EHTModels.AbstractModel","text":"AbstractModel\n\nThe abstract model type. To instantiate your own model type you should subtybe from this model. Additionally you need to implement the following methods to satify the interface: Mandatory Methods\n\nisprimitive: defines whether a model is standalone or is defined in terms of other models.  is the model is primitive then this should return IsPrimitive() otherwise it returns  NotPrimitive()\nvisanalytic: defines whether the model visibilities can be computed analytically. If yes  then this should return IsAnalytic() and the user must to define visibility_point.  If not analytic then visanalytic should return NotAnalytic().\nimanalytic: defines whether the model intensities can be computed pointwise. If yes\n\nthen this should return IsAnalytic() and the user must to define intensity_point. If not analytic then imanalytic should return NotAnalytic().\n\nradialextent: Provides a estimate of the radial extent of the model in the image domain.  This is used for estimating the size of the image, and for plotting.\nflux: Returns the total flux of the model.\n\nOptional Methods:\n\nintensity_point: Defines how to compute model intensities pointwise. Note this is must be defined if imanalytic(::Type{YourModel})==IsAnalytic().\nvisibility_point: Defines how to compute model visibilties pointwise. Note this is   must be defined if visanalytic(::Type{YourModel})==IsAnalytic().\n_visibilities: Vectorized version of visibility_point if you can gain additional speed\nintensitymap: Computes the whole image of the model\nintensitymap!: Inplace version of intensitymap\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.AbstractModifier","page":"Home","title":"EHTModels.AbstractModifier","text":"abstract type AbstractModifier{M<:AbstractModel} <: AbstractModel\n\nAbstract type for image modifiers. These are some model wrappers that can transform any model using simple Fourier transform properties. By default these modified models will have the same analytic properties as the base unmodified model, i.e.\n\njulia> visanalytic(stretched(Disk(), 2.0, 2.0)) == visanalytic(Disk())\ntrue\n\nAdditionally these are classic examples of non-primitive images i.e.,\n\njulia> isprimitive(Comrade.AbstractModifier) == Comrade.NotAnalytic()\n\nAs a result of this the implementation of a model is slightly different\n\ntransform_uv\ntransform_image\nscale_uv\nscale_image\nradialextent\n\nThis methods assume the modifiers are of the form I(x,y) -> fᵢ(x,y)I(gᵢ(x,y)) V(u,v) -> fᵥ(u,v)V(gᵥ(u,v)) where g are the transformimage/uv functions and f are the scaleimage/uv function. See those docstrings for guidance on implementation details.\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.AddModel","page":"Home","title":"EHTModels.AddModel","text":"struct AddModel{T1, T2} <: EHTModels.CompositeModel{T1, T2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call added or Base.+ when constructing a model\n\nExample\n\njulia> m1 = Disk() + Gaussian()\njulia> m2 = added(Disk(), Gaussian()) + Ring()\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.Butterworth","page":"Home","title":"EHTModels.Butterworth","text":"Butterworth{T, N}() where {T}\n\nButterwoth filter in the visibility domain, i.e. the fourier-domain profile\n\n    V_N(r) = left 1 + left( frac1rright)^2N  right^-12\n\ni.e. a unit filtering length and unit flux filter. By default if T isn't given, Butterworth defaults to T=Float64. If futher N isn't given,  Butterworth defaults to N=2.\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.CompositeModel","page":"Home","title":"EHTModels.CompositeModel","text":"abstract type CompositeModel{M1, M2} <: AbstractModel\n\nAbstract type that denotes a composite model. Where we have combined two models together.\n\nImplementation\n\nAny implementation of a composite type must define the following methods:\n\nvisibility_point\nuv_combinator\nimanalytic\nvisanalytic\nComradeBase.intensity_point if model intensity is IsAnalytic\nintensitymap! if model intensity is NotAnalytic\nintensitymap if model intensity is NotAnalytic\nflux\nradialextent\nvisibilities (optional)\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.ConvolvedModel","page":"Home","title":"EHTModels.ConvolvedModel","text":"struct ConvolvedModel{M1, M2} <: EHTModels.CompositeModel{M1, M2}\n\nPointwise addition of two models in the image and visibility domain. An end user should instead call convolved. Also see smoothed(m, σ) for a simplified function that convolves a model m with a Gaussian with standard deviation σ.\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.DensityAnalytic","page":"Home","title":"EHTModels.DensityAnalytic","text":"DensityAnalytic\n\nInternal type for specifying the nature of the model functions. Whether they can be easily evaluated pointwise analytic. This is an internal type that may change.\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.Disk","page":"Home","title":"EHTModels.Disk","text":"$(TYPEDEF)\n\nUniform disk geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases pi^-1  x^2+y^2  1  0  x^2+y^2 geq 0 endcases\n\ni.e. a unit radius and unit flux disk. By default if T isn't given, Disk defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.Gaussian","page":"Home","title":"EHTModels.Gaussian","text":"struct Gaussian{T} <: GeometricModel\n\nGaussian with unit standard deviation and flux. By default if T isn't given, Gaussian defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.GeometricModel","page":"Home","title":"EHTModels.GeometricModel","text":"abstract type GeometricModel <: AbstractModel\n\nA type that defines it is a geometric model. These are usually primitive models, and are usually analytic in Fourier and the image domain. As a result a user only needs to implement the following methods\n\nvisibility_point\nintensity_point\nradialextent\n\nNote that if the geometric model isn't analytic then the usual methods listed in Comrade.AbstractModel for non-analytic models need to be implemented.\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.IsAnalytic","page":"Home","title":"EHTModels.IsAnalytic","text":"struct IsAnalytic <: EHTModels.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has a analytic fourier transform and/or image.\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.IsPrimitive","page":"Home","title":"EHTModels.IsPrimitive","text":"struct IsPrimitive\n\nTrait for primitive model\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.NotAnalytic","page":"Home","title":"EHTModels.NotAnalytic","text":"struct NotAnalytic <: EHTModels.DensityAnalytic\n\nDefines a trait that a states that a model is analytic. This is usually used with an abstract model where we use it to specify whether a model has does not have a easy analytic fourier transform and/or intensity function.\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.NotPrimitive","page":"Home","title":"EHTModels.NotPrimitive","text":"struct NotPrimitive\n\nTrait for not-primitive model\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.PrimitiveTrait","page":"Home","title":"EHTModels.PrimitiveTrait","text":"abstract type PrimitiveTrait\n\nThis trait specifies whether the model is a primitive\n\nNotes\n\nThis will likely turn into a trait in the future so people can inject their models into Comrade more easily.\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.Rectangle","page":"Home","title":"EHTModels.Rectangle","text":"$(TYPEDEF)\n\nUniform rectangle geometrical model, i.e. the intensity profile\n\n    I(xy) = begincases 1  x  05 and y  05  0  (otherwise) endcases\n\ni.e. a unit length and unit flux rectangle. By default if T isn't given, Rectangle defaults to Float64\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.RenormalizedModel","page":"Home","title":"EHTModels.RenormalizedModel","text":"struct RenormalizedModel{M<:AbstractModel, T} <: EHTModels.AbstractModifier{M<:AbstractModel}\n\nRenormalizes the flux of the model to the new value scale*flux(model). We have also overloaded the Base.:* operator as syntactic sugar although I may get rid of this. An end user should not call this directly but instead the renormed function or Base.:* instead.\n\nExample\n\njulia> renormed(Gaussian(), 2.0) == 2.0*Gaussian()\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.RotatedModel","page":"Home","title":"EHTModels.RotatedModel","text":"struct RotatedModel{M<:AbstractModel, T} <: EHTModels.AbstractModifier{M<:AbstractModel}\n\nType for the rotated model. This is more fine grained constrol of rotated model. An end user should not call this directly but instead the rotated function instead.\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.ShiftedModel","page":"Home","title":"EHTModels.ShiftedModel","text":"struct ShiftedModel{M<:AbstractModel, T} <: EHTModels.AbstractModifier{M<:AbstractModel}\n\nShifts the model by Δx units in the x-direction and Δy units in the y-direction. An end user should not call this directly but instead the shifted function instead.\n\n\n\n\n\n","category":"type"},{"location":"#EHTModels.StretchedModel","page":"Home","title":"EHTModels.StretchedModel","text":"struct StretchedModel{M<:AbstractModel, T} <: EHTModels.AbstractModifier{M<:AbstractModel}\n\nStretched the model in the x and y directions, i.e. the new intensity is     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux. An end user should not call this directly but instead the stretched function instead.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:+-Tuple{AbstractModel, AbstractModel}","page":"Home","title":"Base.:+","text":"Base.:+(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(m1+m2, 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.CircularGaussian","page":"Home","title":"EHTModels.CircularGaussian","text":"CircularGaussian(F, θmaj, [x0, y0]; [θunit, ϕunit])\n\nCreate an circular Gaussian.\n\nArgs:\n\nF::Real:   The total flux desnity of the Gaussian.\nθfwhm::Real:   The FWHM size of the Gaussian.\nx0, y0::Real:   The centoral position in the unit of θunit. Default to 0.\nθunit::Unitful:   The unit for θ, x0 and y0, respectively.    Default: θunit=rad.\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.DiskFilter","page":"Home","title":"EHTModels.DiskFilter","text":"DiskFilter(θmaj, [θmin, ϕ]; [θunit, ϕunit])\n\nCreate an elliptical Disk filter with the total flux density of unity centered at the origin.\n\nArgs:\n\nθmaj::Real:   The major-axis size of the disk.\nθmin::Real:   The minor-axis size of the disk. If θmin < 0, then   θmin = θmax (i.e. circular disk). Default to -1.\nϕ::Real:   The position angle of the elliptical disk. Default to 0.\nθunit, ϕunit::Unitful:   The unit for θmaj & θmin and ϕ, respectively.    Default: θunit=rad and ϕ=deg.\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.EllipticalGaussian","page":"Home","title":"EHTModels.EllipticalGaussian","text":"EllipticalGaussian(F, θmaj, [θmin, ϕ, x0, y0]; [θunit, ϕunit])\n\nCreate an elliptical Gaussian.\n\nArgs:\n\nF::Real:   The total flux desnity of the Gaussian.\nθmaj::Real:   The major-axis FWHM size of the Gaussian.\nθmin::Real:   The minor-axis FWHM size of the Gaussian. If θmin < 0, then   θmin = θmax (i.e. circular Gaussian). Default to -1.\nϕ::Real:   The position angle of the Gausian. Default to 0.\nx0, y0::Real:   The centoral position in the unit of θunit. Default to 0.\nθunit::Unitful:   The unit for θmaj, θmin, x0 and y0. Default: θunit=rad.\nϕunit::Unitful:   The unit for ϕ. Default: ϕ=deg.\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.GaussianFilter","page":"Home","title":"EHTModels.GaussianFilter","text":"GaussianFilter(θmaj, [θmin, ϕ]; [θunit, ϕunit])\n\nCreate an elliptical Gaussian filter with the total flux density of unity centered at the origin.\n\nArgs:\n\nθmaj::Real:   The major-axis FWHM size of the Gaussian.\nθmin::Real:   The minor-axis FWHM size of the Gaussian. If θmin < 0, then   θmin = θmax (i.e. circular Gaussian). Default to -1.\nϕ::Real:   The position angle of the Gausian. Default to 0.\nθunit, ϕunit::Unitful:   The unit for θmaj & θmin and ϕ, respectively.    Default: θunit=rad and ϕ=deg.\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.RectangleFilter","page":"Home","title":"EHTModels.RectangleFilter","text":"RectangleFilter(θmaj, [θmin, ϕ]; [θunit, ϕunit])\n\nCreate an rectangle filter with the total flux density of unity.\n\nArgs:\n\nθmaj::Real:   The major-axis size of the rectangle.\nθmin::Real:   The minor-axis size of the rectangle. If θmin < 0, then   θmin = θmax (i.e. square). Default to -1.\nϕ::Real:   The position angle of the rectangle. Default to 0.\nθunit, ϕunit::Unitful:   The unit for θmaj & θmin and ϕ, respectively.    Default: θunit=rad and ϕ=deg.\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.added-Tuple{AbstractModel, AbstractModel}","page":"Home","title":"EHTModels.added","text":"added(m1::AbstractModel, m2::AbstractModel)\n\nCombine two models to create a composite AddModel. This adds two models pointwise, i.e.\n\njulia> m1 = Gaussian()\njulia> m2 = Disk()\njulia> visibility(added(m1,m2), 1.0, 1.0) == visibility(m1, 1.0, 1.0) + visibility(m2, 1.0, 1.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.basemodel-Tuple{EHTModels.AbstractModifier}","page":"Home","title":"EHTModels.basemodel","text":"basemodel(model::AbstractModel)\n\nReturns the base model from a modified model. If there is no basemodel this just return the model itself.\n\nExample\n\njulia> basemodel(stretched(Disk(), 1.0, 2.0)) == Disk()\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.components-Tuple{AbstractModel}","page":"Home","title":"EHTModels.components","text":"components(m::AbstractModel)\n\nReturns the model components for a composite model. This will return a Tuple with all the models you have constructed.\n\nExample\n\njulia> m = Gaussian() + Disk()\njulia> components(m)\n(Gaussian{Float64}(), Disk{Float64}())\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.convolved-Tuple{AbstractModel, AbstractModel}","page":"Home","title":"EHTModels.convolved","text":"convolved(m1::AbstractModel, m2::AbstractModel)\n\nConvolve two models to create a composite ConvolvedModel.\n\njulia> m1 = Ring()\njulia> m2 = Disk()\njulia> convolved(m1, m2)\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.create_filter","page":"Home","title":"EHTModels.create_filter","text":"create_filter(AbstractModel, θmaj, [θmin, ϕ]; [θunit, ϕunit]) => AbstractModel\n\nCreate a filter model by streaching and rotating the given input basemodel.\n\nArgs:\n\nθmaj::Real:   The major-axis size of the rectangle.\nθmin::Real:   The minor-axis size of the rectangle. If θmin < 0, then   θmin = θmax (i.e. square). Default to -1.\nϕ::Real:   The position angle of the rectangle. Default to 0.\nθunit, ϕunit::Unitful:   The unit for θmaj & θmin and ϕ, respectively.    Default: θunit=rad and ϕ=deg.\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.flux","page":"Home","title":"EHTModels.flux","text":"flux(model::AbstractModel)\n\nReturns the total flux of the model.\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.imanalytic-Tuple{Type{<:AbstractModel}}","page":"Home","title":"EHTModels.imanalytic","text":"imanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in the image domain, i.e. we can evaluate its intensity at an arbritrary point. If IsAnalytic() then it will try to call intensity_point to calculate the intensity.\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.intensity_point","page":"Home","title":"EHTModels.intensity_point","text":"intensity_point(model::AbstractModel, x, y, args...)\n\nFunction that computes the pointwise intensity if the model has the trait in the image domain IsAnalytic(). Otherwise it will use construct the image in visibility space and invert it.\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.intensitymap","page":"Home","title":"EHTModels.intensitymap","text":"intensitymap(model::AbstractModel, args...)\n\nComputes the intensity map of model. For the inplace version see intensitymap!\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.intensitymap!","page":"Home","title":"EHTModels.intensitymap!","text":"intensitymap!(buffer::AbstractMatrix, model::AbstractModel, args...)\n\nComputes the intensity map of model by modifying the buffer\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.isprimitive","page":"Home","title":"EHTModels.isprimitive","text":"isprimitive(::Type)\n\nDispatch function that specifies whether a type is a primitive Comrade model. This function is used for dispatch purposes when composing models.\n\nNotes\n\nIf a user is specifying their own model primitive model outside of Comrade they need to specify if it is primitive\n\nstruct MyPrimitiveModel end\nComradeBase.isprimitive(::Type{MyModel}) = ComradeBase.IsPrimitive()\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.posangle-Tuple{EHTModels.RotatedModel}","page":"Home","title":"EHTModels.posangle","text":"posangle(model)\n\n\nReturns the rotation angle of the rotated model\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.radialextent","page":"Home","title":"EHTModels.radialextent","text":"radialextent(model::AbstractModel)\n\nProvides an estimate of the radial size/extent of the model. This is used internally to estimate image size when plotting and using modelimage\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.renormed-Union{Tuple{M}, Tuple{M, Any}} where M<:AbstractModel","page":"Home","title":"EHTModels.renormed","text":"renormed(model, f)\n\n\nRenormalizes the model m to have total flux f*flux(m). This can also be done directly by calling Base.:* i.e.,\n\njulia> renormed(m, f) == f*M\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.rotated-Tuple{Any, Any}","page":"Home","title":"EHTModels.rotated","text":"rotated(model, ξ)\n\n\nRotates the model by an amount ξ in radians in the clockwise direction.\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.scale_image","page":"Home","title":"EHTModels.scale_image","text":"scale_image(model::AbstractModifier, x, y)\n\nReturns a number of how to to scale the image intensity at x y for an modified model\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.scale_uv","page":"Home","title":"EHTModels.scale_uv","text":"scale_image(model::AbstractModifier, u, v)\n\nReturns a number on how to scale the image visibility at u v for an modified model\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.shifted-Tuple{Any, Any, Any}","page":"Home","title":"EHTModels.shifted","text":"shifted(model, Δx, Δy)\n\n\nShifts the model m in the image domain by an amount Δx,Δy in the x and y directions respectively.\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.smoothed-Tuple{Any, Number}","page":"Home","title":"EHTModels.smoothed","text":"smoothed(m::AbstractModel, σ::Number)\n\nSmooths a model m with a Gaussian kernel with standard deviation σ.\n\nNotes\n\nThis uses convolved to created the model, i.e.\n\njulia> m1 = Disk()\njulia> m2 = Gaussian()\njulia> convolved(m1, m2) == smoothed(m1, 1.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.stretched-Tuple{Any, Any, Any}","page":"Home","title":"EHTModels.stretched","text":"stretched(model, α, β)\n\n\nStretches the model m according to the formula     Iₛ(x,y) = 1/(αβ) I(x/α, y/β), where were renormalize the intensity to preserve the models flux.\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.transform_image","page":"Home","title":"EHTModels.transform_image","text":"transform_image(model::AbstractModifier, x, y)\n\nReturns a transformed x and y according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.transform_uv","page":"Home","title":"EHTModels.transform_uv","text":"transform_uv(model::AbstractModifier, u, v)\n\nReturns a transformed u and v according to the model modifier\n\n\n\n\n\n","category":"function"},{"location":"#EHTModels.visanalytic-Tuple{Type{<:AbstractModel}}","page":"Home","title":"EHTModels.visanalytic","text":"visanalytic(::Type{<:AbstractModel})\n\nDetermines whether the model is pointwise analytic in Fourier domain, i.e. we can evaluate its fourier transform at an arbritrary point. If IsAnalytic() then it will try to call visibility_point to calculate the complex visibilities. Otherwise it fallback to using the FFT that works for all models that can compute an image.\n\n\n\n\n\n","category":"method"},{"location":"#EHTModels.visibility_point","page":"Home","title":"EHTModels.visibility_point","text":"visibility_point(model::AbstractModel, u, v, args...)\n\nFunction that computes the pointwise visibility. This must be implemented in the model interface if visanalytic(::Type{MyModel}) == IsAnalytic()\n\n\n\n\n\n","category":"function"}]
}
